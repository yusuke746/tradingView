from __future__ import annotations

from typing import Any, Dict, Optional


def build_entry_filter_payload(
    *,
    symbol: str,
    action: str,
    now_ts: float,
    normalized_trigger: Optional[Dict[str, Any]],
    trigger_age_sec: Optional[int],
    stats_window_signals: Any,
    mt5_positions_summary: Any,
    zones_context: Optional[Dict[str, Any]],
    sma_context: Optional[Dict[str, Any]],
    volatility_context: Optional[Dict[str, Any]],
    spread_context: Optional[Dict[str, Any]],
    session_context: Optional[Dict[str, Any]],
    qt_available: bool,
    qt_side: Any,
    qt_dir: str,
    qt_strength_norm: str,
    qt_age_sec: Optional[int],
    qt_alignment_vs_trigger: str,
    qt_source: Any,
    q_age_sec_legacy: int,
    strong_flag: bool,
    is_strong_momentum: bool,
    q_trigger_type: str,
    momentum_factor: float,
    confirm_u: int,
    confirm_n: int,
    opp_u: int,
    opp_n: int,
    confluence_score: int,
    confluence_score_base: int,
    strong_bonus: int,
    opposition_score: int,
    w_confirm: float,
    w_oppose: float,
    fvg_same: int,
    fvg_opp: int,
    zones_same: int,
    zones_opp: int,
    sweep_grade: str,
    sweep_age_sec: Optional[int],
    zone_age_sec: Optional[int],
    sync_delta_sec: Optional[int],
    setup_path: str,
    bid: float,
    ask: float,
    m15_sma20: float,
    m15_trend: str,
    trend_alignment: str,
    atr_m5_approx: Any,
    atr_points_approx: Any,
    atr_to_spread_approx: Any,
    spread_points: float,
    spread_flag: str,
    price_drift: Any,
    local_multiplier: float,
    entry_freshness_sec: float,
) -> Dict[str, Any]:
    """Build the ContextJSON payload for ENTRY scoring prompt.

    Behavior-preserving extraction from the main bridge.
    This function should only assemble the dict; callers own all computations.
    """

    payload: Dict[str, Any] = {
        "symbol": symbol,
        "proposed_action": action,
        "trigger": {
            "source": (normalized_trigger or {}).get("source"),
            "side": (normalized_trigger or {}).get("side"),
            "signal_type": (normalized_trigger or {}).get("signal_type"),
            "event": (normalized_trigger or {}).get("event"),
            "confirmed": (normalized_trigger or {}).get("confirmed"),
            "signal_time": (normalized_trigger or {}).get("signal_time"),
            "price": (normalized_trigger or {}).get("price"),
            "age_sec": trigger_age_sec,
        },
        "signals_window": stats_window_signals,
        "mt5_positions_summary": mt5_positions_summary,
        "zones_context": zones_context,
        "sma_context": sma_context,
        "volatility_context": volatility_context,
        "spread_context": spread_context,
        "session_context": session_context,
        "qtrend_context": {
            "available": bool(qt_available),
            "side": qt_side,
            "direction": qt_dir,
            "strength": qt_strength_norm,
            "age_sec": qt_age_sec,
            "alignment_vs_trigger": qt_alignment_vs_trigger,
        },
        "qtrend": {
            "side": qt_side,
            "age_sec": int(q_age_sec_legacy),
            "is_strong": bool(is_strong_momentum),
            "is_strong_momentum": bool(is_strong_momentum),
            "trigger_type": q_trigger_type,
            "momentum_factor": float(momentum_factor),
            "source": qt_source,
            "strong_after_q": bool(strong_flag),
        },
        "confluence": {
            "confirm_unique_sources": int(confirm_u),
            "confirm_signals": int(confirm_n),
            "oppose_unique_sources": int(opp_u),
            "oppose_signals": int(opp_n),
            # IMPORTANT: these are local heuristic points (small integers), NOT the AI output 1-100 score.
            "local_points": int(confluence_score),
            "local_points_base": int(confluence_score_base),
            "qtrend_strong_bonus_points": int(strong_bonus),
            "opposition_score": int(opposition_score),
            "weighted_confirm_score": float(w_confirm),
            "weighted_oppose_score": float(w_oppose),
            "fvg_touch_same": int(fvg_same),
            "fvg_touch_opp": int(fvg_opp),
            "zones_touch_same": int(zones_same),
            "zones_touch_opp": int(zones_opp),
            "setup_grade": sweep_grade,
            "setup_path": setup_path,
            "sweep_age_sec": sweep_age_sec,
            "zone_age_sec": zone_age_sec,
            "sync_delta_sec": sync_delta_sec,
            "note": "touch系(FVG/Zones)は瞬間イベント。Opposition評価は過剰反応せず、構造(confirmed)と区別する。",
        },
        "market": {
            "bid": bid,
            "ask": ask,
            "m15_sma20": m15_sma20,
            "m15_trend": m15_trend,
            "trend_alignment": trend_alignment,
            "atr_m5_approx": atr_m5_approx,
            "atr_points_approx": atr_points_approx,
            "atr_to_spread_approx": atr_to_spread_approx,
            "spread_points": spread_points,
            "spread_flag": spread_flag,
        },
        "price_drift": price_drift,
        "constraints": {
            "ai_confluence_score_range": [1, 100],
            "lot_multiplier_range": [0.5, 2.0],
            "local_multiplier": float(local_multiplier),
            "final_multiplier_max": 2.0,
            "freshness_sec": float(entry_freshness_sec),
            "note": "Return JSON only. Score 70+ only when confluence is truly strong AND market conditions (ATR vs spread, trend alignment) are acceptable. Be conservative on uncertainty.",
        },
        # keep for forward compatibility/debug; not currently consumed by AI
        "_meta": {"now_ts": float(now_ts)},
    }

    return payload
